/// Generates Dart code for environment configuration
class CodeGenerator {
  final List<String> environments;
  final Map<String, Map<String, String>> envData;
  final List<String> allKeys;

  CodeGenerator({
    required this.environments,
    required this.envData,
    required this.allKeys,
  });

  /// Generate the complete Dart code
  String generate() {
    final buffer = StringBuffer();

    // Header comment
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by enviro package');
    buffer.writeln('// Generated at: ${DateTime.now().toIso8601String()}');
    buffer.writeln();
    buffer.writeln('// ⚠️  IMPORTANT: Make sure to add .env files to your pubspec.yaml:');
    buffer.writeln('// flutter:');
    buffer.writeln('//   assets:');
    buffer.writeln('//     - .env');
    buffer.writeln('//     - .env-staging');
    buffer.writeln('//     - .env-production');
    buffer.writeln();

    // Imports
    buffer.writeln("import 'dart:async';");
    buffer.writeln("import 'package:flutter/services.dart' show rootBundle;");
    buffer.writeln();

    // Generate EnviroEnvironment enum
    buffer.writeln(_generateEnvironmentEnum());
    buffer.writeln();

    // Generate Enviro class
    buffer.writeln(_generateEnviroClass());

    return buffer.toString();
  }

  /// Generate the EnviroEnvironment enum
  String _generateEnvironmentEnum() {
    final buffer = StringBuffer();

    buffer.writeln('/// Available environments');
    buffer.writeln('enum EnviroEnvironment {');

    for (var i = 0; i < environments.length; i++) {
      final env = environments[i];
      buffer.write('  $env');
      if (i < environments.length - 1) {
        buffer.writeln(',');
      } else {
        buffer.writeln();
      }
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// Generate the main Enviro class
  String _generateEnviroClass() {
    final buffer = StringBuffer();

    buffer.writeln('/// Main class for accessing environment variables');
    buffer.writeln('class Enviro {');
    buffer.writeln('  Enviro._(); // Private constructor');
    buffer.writeln();

    // Environment to file path mapping (pointing to root .env files)
    buffer.writeln('  /// Mapping of environments to asset file paths');
    buffer.writeln('  static const _envFilePaths = <EnviroEnvironment, String>{');
    for (var i = 0; i < environments.length; i++) {
      final env = environments[i];
      final fileName = _getEnvFileName(env);
      buffer.write("    EnviroEnvironment.$env: '$fileName'");
      if (i < environments.length - 1) {
        buffer.writeln(',');
      } else {
        buffer.writeln();
      }
    }
    buffer.writeln('  };');
    buffer.writeln();

    // Current environment field
    buffer.writeln('  /// Current active environment (defaults to DEFAULT)');
    buffer.writeln('  static EnviroEnvironment _currentEnvironment = EnviroEnvironment.DEFAULT;');
    buffer.writeln();

    // Cache for loaded environment data
    buffer.writeln('  /// Cache for loaded environment data');
    buffer.writeln('  static final Map<EnviroEnvironment, Map<String, String>> _cache = {};');
    buffer.writeln();

    // Initialization status
    buffer.writeln('  /// Whether the current environment has been loaded');
    buffer.writeln('  static bool _isInitialized = false;');
    buffer.writeln();

    // setEnvironment method
    buffer.writeln('  /// Set the current environment');
    buffer.writeln('  /// If not called, DEFAULT environment (.env) will be used');
    buffer.writeln('  /// Call this before accessing any environment variables');
    buffer.writeln('  static Future<void> setEnvironment(EnviroEnvironment environment) async {');
    buffer.writeln('    _currentEnvironment = environment;');
    buffer.writeln('    _isInitialized = false;');
    buffer.writeln('    await _loadEnvironment();');
    buffer.writeln('  }');
    buffer.writeln();

    // currentEnvironment getter
    buffer.writeln('  /// Get the current environment');
    buffer.writeln('  static EnviroEnvironment get currentEnvironment => _currentEnvironment;');
    buffer.writeln();

    // Load environment method
    buffer.writeln('  /// Load environment data from assets');
    buffer.writeln('  static Future<void> _loadEnvironment() async {');
    buffer.writeln('    if (_isInitialized && _cache.containsKey(_currentEnvironment)) {');
    buffer.writeln('      return; // Already loaded');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    try {');
    buffer.writeln('      // Load current environment file');
    buffer.writeln('      final filePath = _envFilePaths[_currentEnvironment]!;');
    buffer.writeln('      final content = await rootBundle.loadString(filePath);');
    buffer.writeln('      _cache[_currentEnvironment] = _parseEnvFile(content);');
    buffer.writeln();
    buffer.writeln('      // Also load DEFAULT if not already loaded (for fallback)');
    buffer.writeln('      if (_currentEnvironment != EnviroEnvironment.DEFAULT && !_cache.containsKey(EnviroEnvironment.DEFAULT)) {');
    buffer.writeln("        final defaultContent = await rootBundle.loadString(_envFilePaths[EnviroEnvironment.DEFAULT]!);");
    buffer.writeln('        _cache[EnviroEnvironment.DEFAULT] = _parseEnvFile(defaultContent);');
    buffer.writeln('      }');
    buffer.writeln();
    buffer.writeln('      _isInitialized = true;');
    buffer.writeln('    } catch (e) {');
    buffer.writeln("      throw Exception('Failed to load environment file: \$e. Make sure .env files are added to pubspec.yaml assets section.');");
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln();

    // Parse env file method
    buffer.writeln('  /// Parse .env file content');
    buffer.writeln('  static Map<String, String> _parseEnvFile(String content) {');
    buffer.writeln('    final result = <String, String>{};');
    buffer.writeln('    final lines = content.split(\'\\n\');');
    buffer.writeln();
    buffer.writeln('    for (var line in lines) {');
    buffer.writeln('      line = line.trim();');
    buffer.writeln();
    buffer.writeln('      // Skip empty lines and comments');
    buffer.writeln("      if (line.isEmpty || line.startsWith('#')) {");
    buffer.writeln('        continue;');
    buffer.writeln('      }');
    buffer.writeln();
    buffer.writeln("      final separatorIndex = line.indexOf('=');");
    buffer.writeln('      if (separatorIndex == -1) continue;');
    buffer.writeln();
    buffer.writeln('      final key = line.substring(0, separatorIndex).trim();');
    buffer.writeln('      var value = line.substring(separatorIndex + 1).trim();');
    buffer.writeln();
    buffer.writeln('      // Remove quotes');
    buffer.writeln('      if (value.length >= 2) {');
    buffer.writeln('        if ((value.startsWith(\'"\') && value.endsWith(\'"\')) ||');
    buffer.writeln("            (value.startsWith(\"'\") && value.endsWith(\"'\"))) {");
    buffer.writeln('          value = value.substring(1, value.length - 1);');
    buffer.writeln('        }');
    buffer.writeln('      }');
    buffer.writeln();
    buffer.writeln('      if (key.isNotEmpty) {');
    buffer.writeln('        result[key] = value;');
    buffer.writeln('      }');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    return result;');
    buffer.writeln('  }');
    buffer.writeln();

    // Helper method to get value with fallback
    buffer.writeln('  /// Get value from current environment with fallback to DEFAULT');
    buffer.writeln('  static String _getValue(String key) {');
    buffer.writeln('    if (!_isInitialized) {');
    buffer.writeln("      throw Exception('Enviro not initialized. Call await Enviro.setEnvironment() or await Enviro.initialize() before accessing values.');");
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    // Try to get from current environment');
    buffer.writeln('    final currentEnvData = _cache[_currentEnvironment];');
    buffer.writeln('    if (currentEnvData != null && currentEnvData.containsKey(key)) {');
    buffer.writeln('      return currentEnvData[key]!;');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    // Fallback to DEFAULT environment');
    buffer.writeln('    final defaultEnvData = _cache[EnviroEnvironment.DEFAULT];');
    buffer.writeln('    if (defaultEnvData != null && defaultEnvData.containsKey(key)) {');
    buffer.writeln('      return defaultEnvData[key]!;');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln("    throw Exception('Key \"\$key\" not found in any environment');");
    buffer.writeln('  }');
    buffer.writeln();

    // Initialize method (optional - auto-loads DEFAULT)
    buffer.writeln('  /// Initialize with DEFAULT environment');
    buffer.writeln('  /// This is optional - you can directly call setEnvironment()');
    buffer.writeln('  static Future<void> initialize() async {');
    buffer.writeln('    await setEnvironment(EnviroEnvironment.DEFAULT);');
    buffer.writeln('  }');
    buffer.writeln();

    // Generate getters for each key
    for (final key in allKeys) {
      buffer.writeln(_generateGetter(key));
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// Get environment file name from environment enum name
  String _getEnvFileName(String envName) {
    if (envName == 'DEFAULT') {
      return '.env';
    }
    return '.env-${envName.toLowerCase().replaceAll('_', '-')}';
  }

  /// Generate a getter for a specific key
  String _generateGetter(String key) {
    final buffer = StringBuffer();

    // Convert KEY_NAME to keyName (camelCase)
    final getterName = _toCamelCase(key);

    // Detect type based on values across all environments
    final type = _detectType(key);

    buffer.writeln('  /// Get $key from current environment');
    buffer.writeln('  /// Falls back to DEFAULT (.env) if not found in current environment');
    buffer.write('  static $type get $getterName ');

    if (type == 'String') {
      buffer.writeln("=> _getValue('$key');");
    } else if (type == 'int') {
      buffer.writeln("=> int.parse(_getValue('$key'));");
    } else if (type == 'double') {
      buffer.writeln("=> double.parse(_getValue('$key'));");
    } else if (type == 'bool') {
      buffer.writeln("=> _getValue('$key').toLowerCase() == 'true';");
    }

    buffer.writeln();

    return buffer.toString();
  }

  /// Convert SNAKE_CASE to camelCase
  String _toCamelCase(String snakeCase) {
    final parts = snakeCase.toLowerCase().split('_');
    if (parts.isEmpty) return snakeCase.toLowerCase();

    final result = StringBuffer(parts[0]);
    for (var i = 1; i < parts.length; i++) {
      if (parts[i].isNotEmpty) {
        result.write(parts[i][0].toUpperCase());
        if (parts[i].length > 1) {
          result.write(parts[i].substring(1));
        }
      }
    }

    return result.toString();
  }

  /// Detect the type of a variable based on its values
  String _detectType(String key) {
    final values = <String>[];
    for (final env in environments) {
      final value = envData[env]![key];
      if (value != null) {
        values.add(value);
      }
    }

    if (values.isEmpty) return 'String';

    if (values.every((v) => int.tryParse(v) != null)) {
      return 'int';
    }

    if (values.every((v) => double.tryParse(v) != null)) {
      return 'double';
    }

    if (values.every((v) => v.toLowerCase() == 'true' || v.toLowerCase() == 'false')) {
      return 'bool';
    }

    return 'String';
  }
}